 [理由]  
 一時変数の問題点は、一時的でローカルだということにある。  
 使われているメソッドのコンテキストの中でしか参照できないので、一時変数にアクセスするためにはメソッドを長くする以外に方法がなく、  
 そのため一時変数はメソッドの長大化を助長してしまう。  
 
 一時変数を問い合わせメソッドに置き換えれば、クラス内のすべてのメソッドがその情報にアクセスできるようになる。  
 これは、クラスのコードをクリーンにするために非常に役に立つ。  
 「一時変数から問い合わせメソッドへ」は、「メソッドの抽出」(Extract Method)を行う前の重要なステップである。  
 ローカル変数は、メソッドの抽出を妨げるので、できる限りの多くの一時変数を問い合わせメソッド呼び出しに変えられるとよい。  
 
 このリファクタリングが簡単に使えるのは、一時変数が1度だけしか代入されず、代入される値を生成する式に副作用がない時である。  
 それ以外の場合はこれよりも難しくなるのが、不可能ではない。  
 
 作業を楽にするために「一時変数の分割」(Split Temporary Variable)や「問い合わせと更新の分離」(Separate Query from Modifier)を先に行わなければならない場合がある。  
 一時変数が計算結果の蓄積に使われている場合(たとえば、ループによる合計計算)には、問い合わせメソッドにロジックをコピーする必要がある。  

 [手順]  
 ここで説明するのは単純な場合である。  
 1. 代入文の右辺を抽出してメソッドにする。  
 -> メソッドは、最初は非公開とする。後で他の用途が見つかったら、保護属性はそのときに緩めればよい。  
 -> 抽出したメソッドは、副作用がないもの、つまりオブジェクトを書き換えないものでなければならない。  
    副作用がある場合、「問い合わせと更新の分離」(Separate Query from Modifier)を使う。  
 2. テストする。  
 3. 一時変数に対して「一時変数のインライン化」をかける。  
 
 一時変数は、ループ内のまとめ情報を格納するために使われることが多い。  
 その場合、ループ全体をメソッドに抽出する。こうすると、うるさいコードが何行も取り除ける。  
 第1章1.3節「statementメソッドの分解、再配置」のtotal_chargeメソッドのように、ループで複数の値を集計していることもある。  
 その場合は、1つ1つの一時変数のためにループをコピーし、個々の一時変数を問い合わせメソッド呼び出しに置き換えられるようにする。  
 ループは単純なはずなので、コードの重複による危険はほとんどない。  
 
 このようにすると、パフォーマンスが心配になるかもしれないが、これ以外のパフォーマンス問題ともども、今は考えないようにする。  
 10回のうち9回までは、パフォーマンスが問題になることはない。  
 本当に問題になるときには、最適化段階に入ってから解決する。  
 コードをきれいに切り分けてあると、リファクタリングしなければ見落としていたような強力な最適化方法が見つかることが多い。  
 最悪の場合でも、一時変数に戻すのは簡単である。  
