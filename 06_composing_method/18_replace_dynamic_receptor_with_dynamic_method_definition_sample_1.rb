# 6.18 動的レセプタから動的メソッド定義へ : method_missingを使わない動的な委譲
# 委譲(処理を他のオブジェクトに委ねること)は、ソフトウェア開発ではよく見られる。
# 委譲は自分で明示的にメソッドを定義する方法でも、ForwardableなどのRuby標準ライブラリの機能を活用する方法でも処理できる。
# これらのテクニックを使うと、どのメソッドの処理を従属オブジェクトに委ねるかをコントロールできる。
# しかし、特に指定せずにすべてのメソッドを委譲したい場合もある。
#
# Rubyの標準ライブラリはdelegateライブラリという形でこの機能も提供しているが、
# ここではサンプルの都合上、独自のものを実装しなければならないという想定で話を進めていく。
#
# 委譲を単純に処理するためには(クラスがデフォルトで受け取るすべての標準メソッドの定義を解除した方がよいということを考えないものとして)、
# method_missingを使ってすべてのメソッド呼び出しをそのまま従属オブジェクトに渡してしまえばよい。
class Decorator
  def initialize(subject)
    @subject = subject
  end

  def method_missing(sym, *args, &block)
    @subject.send sym, *args, &block
  end
end
# この解は動作するが、ミスを犯すと様々な問題が起きる可能性がある。
# たとえば、従属オブジェクトが持たないメソッドを呼び出すと、NoMethodErrorが生成される。
# メソッド呼び出しはデコレータに対して行なっているのに、エラーを起こしているのは従属オブジェクトなので、
# どこが問題なのかを突き止めるためにとても苦労する場合がある。
# それでも、おかしなオブジェクトがNoMethodErrorを生成するのは、スタックレベルが深くなり過ぎる(SystemStackError)と比べればかなりマシ。
# 従属インスタンス変数を使い忘れたとか、存在しないメソッドや綴りに謝りのあるメソッドを使おうとしたといった単純な誤りでも、このエラーは起きることがある。
# このエラーが起きたときのフィードバッグは、何かがおかしくなることだけで、Rubyは何が起きているのかを正確に把握していない。
# 実行時に手元にあるデータを使って動的にメソッドを定義すれば、これらの問題は避けられる。
