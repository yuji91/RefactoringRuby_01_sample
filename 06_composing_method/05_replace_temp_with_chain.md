 [理由]  
 別々の行を使ってメソッドを呼び出せば、それで必要な処理は実行されるが、メソッド呼び出しを連鎖的に行って(チェインして)、  
 流れるような(fluent)インターフェースを提供するとよい場合がある。  
 上のサンプルで、ローカル変数のexpectationに期待値(mock.expects()の戻り値)を代入しているのは、  
 引数(argument)と戻り値(returns)を指定できるようにするためでしかない。  
 メソッドのチェイニングを使った解なら、このローカル変数は不要になる。  
 メソッドのチェイニングを使うと、自然に読めるようにコードを組み合わせられるインターフェイスが使えるので、保守性も上がる。  
 
 一見したところ、「一時変数からチェインへ」は「委譲の隠蔽」(Hide Delegate)のちょうど逆のように感じられる。  
 しかし、「委譲の隠蔽」は、あるタイプのオブジェクトが別のタイプのオブジェクトに処理を委ねているという事実を隠すために使うというところが大きな違いである。  
 「委譲の隠蔽」はカプセル化の問題である。  
 呼び出し元のオブジェクトは、一連の中間オブジェクトを経由せずに、下位のオブジェクトに情報を要求してはならず、直近のオブジェクトに仕事をしてくれと頼まなければならない。  
 
 それに対し、「一時変数からチェインへ」では、関わるオブジェクトは1種類だけである。  
 その目的は、メソッド呼び出しのチェイニングを認めることによって、1つのオブジェクトの表現力を高めることである。   

 [手順]  
 1. チェイニングできるようにしたいメソッドからはselfを返すように書き換える。  
 2. テストする。  
 3. ローカル変数を取り除き、メソッド呼び出しをチェイニングする。  
 4. テストする。  
